---
title: "Test seqICP on ETFs data - Daniel"
output:
---


```{r}
library("dplyr")
library("seqICP")
library("readr")
library("here")
```

```{r}
inputs_path <- file.path(here(), "src", "data", "inputs")
```


First, lets load the dataset:

```{r}
df <- read_csv(file = file.path(inputs_path, "2000_etfs_macro_transf.csv"))
head(df)
```
```{r}
dim(df)
```


Below, we list the hypothesis of the seqICP and then we test them:

> 1)
> 2)

Since L = length(grid) and grid is always a vector with three elements, then

L.tot = choose(L, 2) = choose(3, 2) = 3

is always true.

Once we have L.tot, we define a list of indices to represent the proper subset of the time steps in X. Each of the elements of this list can be considered ENVIRONMENTS. The authors consider only the situation where we have the number of environments is 2*l.tot. Thus, we always have 6 environments. The problem is that environments 2 and 3 intersect each other. Thus, we consider 6-2=4 final environments when computing the relevant test statistics.

```{r}
X <- df %>% dplyr::select(-date) %>% as.matrix(df)

# number of observations
n <- nrow(X)

X <- cbind(matrix(1, n, 1),X)

# number of variables
d <- ncol(X)

grid <- c(0, round(nrow(X)/2), nrow(X))
L <- length(grid)
L.tot <- choose(L,2)

# compute all combinations of elements on the grid
t <- combn(L,2,simplify=TRUE)

# initialize variables
Z <- vector("list",2*L.tot)
env <- vector("list",2*L.tot)
fullenv <- L-1
for(i in 1:L.tot){
  cp1 <- grid[t[1,i]]
  cp2 <- grid[t[2,i]]
  env[[i]] <- (cp1+1):cp2
  if(cp1==0 & cp2!=n){
    env[[i+L.tot]] <- (cp2+1):n
  }
  else if(cp2==n & cp1!=0){
    env[[i+L.tot]] <- 1:cp1
  }
  else if(cp1==0 & cp2==n){
    env[[i+L.tot]] <- 1:n
  }
  else{
    env[[i+L.tot]] <- c(1:cp1,(cp2+1):n)
  }
}

# write grid to CP
CP <- grid

# compute relevant comparisons
pairwise <- cbind((1:L.tot)[-fullenv],(1:L.tot)[-fullenv]+L.tot)

# set L.tot to the full number of environments
L.tot <- 2*L.tot
```

```{r}
pairwise
```









